<p><a href="https://www.acmicpc.net/problem/1181">1181번: 단어 정렬</a></p>

<p>이번에 푼 문제는 단어를 두가지 조건에 따라 정렬하는것이었다.</p>

<p>조건은 아래와같다.</p>

<ol>
  <li>단어 길이 순 오름차순 정렬</li>
  <li>길이가같다면 알파벳 순으로 정렬</li>
  <li>중복되는 단어는 하나로 통일</li>
</ol>

<h3 id="try1-pq">TRY1. PQ</h3>

<p>1번 조건을 보고 자료구조시간에 배운 priorityQueue가 생각났다.</p>

<p>구글링 결과 코틀린에서 pq를 사용하기 위해서는</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.*</span>
</code></pre></div></div>

<p>위와 같이 사전에 import가 필요하다.</p>

<p>pq를 사용해 코드를 짜보니 조건2가 걸렸다. pair을 사용해 첫번째 원소 기준으로 정렬을 하려고했는데 막상해보니 pq는 일반적인 방법으로는 pair을 원소로 넣을 수 없었다.</p>

<p>검색을 했더니 Comparator라는걸 사용해서 어떻게 할수 있다고 나와있어서 적용해보았는데 comparator 공부를 덜 해서 그런지 문법적인 오류와 실행오류가 꽤 많이 나왔다.</p>

<p>그런 상황에서 collection을 정렬하는방법을 보니 더 간단해 보여서 평소에 잘사용하는 mutableList과 정렬함수 sortedBy를 사용해 정렬을 시도해보았다.</p>

<h3 id="try2-sortedby">TRY2. sortedBy{}</h3>

<p>sortedBy를 사용해 정렬을 시도했다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//대충 이렇게</span>
<span class="n">list</span><span class="p">.</span><span class="nf">sortedBy</span><span class="p">{</span><span class="n">it</span><span class="p">.</span><span class="n">length</span><span class="p">}</span>
<span class="n">list</span><span class="p">.</span><span class="nf">forEach</span><span class="p">{</span>
	<span class="nf">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>왠지 정렬이 되지 않았다. 참고한 블로그에서는 되는것같았는데,, 좀 당황스러웠다.</p>

<h3 id="try3-sortedwithcomparatorthenby">TRY3. sortedWith{},comparator,thenBy{}</h3>

<p>문제를 찾았다. sortedBy로 리턴되는 값이 정렬된 리스트인데 그걸 저장하지 않고 그냥 이전 데이터를 다룬것이 문제였다!</p>

<p>이부분을 찾다가 블로그에서 이 조건들과 상당히 흡사한 코드를 찾았다. comparaotr로 정렬조건을 명시한 후 두번째 조건은 thenBy를 사용해 comparaor를 결합하여 만든다.</p>

<p>이후 sortedWith를 사용해서 정렬을 완료했다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">lengthComparator</span><span class="p">=</span><span class="n">compareBy</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;{</span><span class="n">it</span><span class="p">.</span><span class="n">length</span><span class="p">}</span>
    <span class="kd">val</span> <span class="py">comparator</span><span class="p">=</span><span class="n">lengthComparator</span><span class="p">.</span><span class="nf">thenBy</span><span class="p">{</span><span class="n">it</span><span class="p">}</span>

    <span class="kd">val</span> <span class="py">words</span><span class="p">=</span> <span class="n">mutableSetOf</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;()</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">num</span><span class="p">){</span>
        <span class="kd">val</span> <span class="py">word</span><span class="p">=</span><span class="nf">readLine</span><span class="p">()</span><span class="o">!!</span>
        <span class="n">words</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">words</span><span class="p">.</span><span class="nf">sortedWith</span><span class="p">(</span><span class="n">comparator</span><span class="p">).</span><span class="nf">forEach</span><span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"$it\n"</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="try4-mutableset사용">TRY4. mutableSet사용</h3>

<p>출력을 해보니 결과가 뭔가 달랐다. 생각해보니 조건3을 까맣게 잊고있었다!</p>

<p>중복을 없애는데는 set이 가장 간편해보여 mutableList→mutableSet으로 자료형을 변경하였다.</p>

<p>여기까지 해서 문제 제출을 했더니 720ms가 나왔다.</p>

<hr />

<h3 id="advanced">[Advanced]</h3>
<p>1등의 시간을 보니 252ms가 나왔다.</p>

<p>처리시간이 세배정도 차이가 나는 것을 보니 개선의 여지가 다분해 보였다.</p>

<p>일단 상위권 코드들을 모아서 내 코드와 차이점을 분석 해보았다.</p>

<ul>
  <li>
    <p>차이점1 : 입출력 버퍼</p>

    <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">BufferedReader</span><span class="p">(</span><span class="nc">InputStreamReader</span><span class="p">(</span><span class="nc">System</span><span class="p">.</span><span class="n">`in`</span><span class="p">))</span>
  <span class="nc">BufferedWriter</span><span class="p">(</span><span class="nc">OutputStreamWriter</span><span class="p">(</span><span class="nc">System</span><span class="p">.</span><span class="k">out</span><span class="p">))</span>
</code></pre></div>    </div>

    <p>아래 블로그에 따르면 기존에 썼던 코드는 키보드 입력 즉시 입력을 프로그램으로 보내는것이고 위의 입출력버퍼를 사용하면 키보드 입력을 버퍼에 임시로 모아두었다가 버퍼가 다 차거나 개행문자를 만났을때 한번에 프로그램으로 보낸다.</p>

    <p>그냥 들었을때는 둘이 큰 차이가 없어보이지만 데이터 입출력은 자원이 많이 필요하므로 한번에 보내는것이 더 효율적이라고 한다.</p>

    <p><a href="https://soopeach.tistory.com/257">BufferedReader &amp; BufferedWriter - 빠른 입출력(Kotlin - 코틀린). feat, 자바</a></p>
  </li>
  <li>
    <p>차이점2 : 정렬방식</p>

    <p>자료구조시간에 정렬 방법을 몇개 배웠었는데 그중 퀵솔트 방식을 쓴 코드들이 종종 보였다. 이부분은 기억이 희미하기도하고 다 못배운 정렬방법도 있어서 나중에 다시 공부해서 따로 포스팅을 하기로한다.</p>
  </li>
</ul>
