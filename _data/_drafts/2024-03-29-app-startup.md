---
title: "Android startup : Cold start, Warm start, Hot start"
#excerpt: ""
categories: android
tags:
  - [cold start, warm start, hot start, ]
date: 2023-10-30 21:41
last_modified_at: 2023-10-30 21:41
toc: ture
toc_sticky: true
---


요즘 이런저런 공부를 하다보니 cold start, warm start, hot start에 대한 개념을 알게 되었다.

사실 예전에 몇번인가 들어보았는데 잠깐 찾아보고 잊어버려서 까먹지않기 위해서 블로그에 정리해보기로 했다.

## App startup states

안드로이드 앱은 세가지의 시작 상태를 가진다.

1. Cold start
2. Warm start
3. Hot start

만약 안드로이드 앱을 시작되는것을 뜨거운 차를 만드는 과정에 비교해보면 외우기 쉽다.

우리는 차를 탈 뜨거운 물이 필요한 상황이고, 각 상태는 끓이기 전 물의 온도와 비슷하다.


### 🧊 Cold start

cold start는 찬물을 끓이는 과정과 비슷하다.

시간이 많이 걸리고 필요한 에너지도 많다.

cold start는 앱 프로세스가 할당되지 않은 상황에서 완전히 처음 앱을 실행시키는 상황이다.

cold start로 앱을 실행시키는 과정은 아래와 같다.

1. 일단 사용자가 앱을 실행했다면 앱을 로드하고 시작한다.
2. 앱이 실행될때까지 시간이 필요하므로 그때까지 빈창을 표시한다.
3. 앱 프로세스를 만든다.
4. 앱 프로세스가 만들어지고 첫번째 프레임이 그려지면 시스템은 빈 화면과 앱의 액티비티 화면을 교체하여 사용자에게 보여준다.

### 💧 Warm start

warm start는 미지근한 물을 끓이는 과정을 생각하면 된다.

찬물보다는 들어가는 시간이나 에너지가 적다.

warm start는 사실 이 셋중에 가장 설명하기 애매한 상태인것 같다.

대충 요약하자면 일부는 종료되고 일부는 살아있는 상태이다.



예를 들어 사용자가 앱을 종료할 경우 프로세스가 살아있을 수 있는 경우에 앱을 다시 시작할 경우라던가,
혹은 ...

하여간 warm start는 이런 과정의 특성상 cold start의 과정 일부를 실행하게 된다.


### ♨️ hot start

예상되겠지만 Hot start는 뜨거운 물을 끓이는 것과 비슷하다.

잠시 백그라운드 앱을 실행시키다가 다시 실행한 경우가 이런 경우이다.

이경우 프로세스는 물론이고 객체나 메모리 또한 유지되므로 별다른 오버헤드 없이 앱을 실행시킬 수 있다.

hot start의 경우 앱은 onCreate() 부터 다시 실행된다.

## start performance

공식 문서나 경험상 앱의 시작 성능은 UX의 매우 중요한 요소이다.

때문에 당연스럽게 시작 성능 개선에 대한 고민도 이어진다.

그런데 우리는 무엇을 기준으로 앱의 시작 성능을 개선해야 하는 것일까?

물론 빠르면 빠를수록 좋겠지만 구체적 달성 수치가 있어야 할 것 같다.

### Android vitals

android vitals에서 말하는 성능의 기준은 아래와 같다.

> cold start<=5s <br>
warm start<=2s <br>
hot start<=1.5s

보다시피 cold start의 경우 5초 이내에 완료되어야하며, warm start는 2초, hot start는 1.5초가 기준이다.

그런데 여기서 또 궁금한 점이 생긴다.

안드로이드 앱 시작이 완료된 순간이 어느 지점인지에 대한것이다.

cold start의 경우 첫번째 프레임이 그려질 때 빈 화면과 액티비티 화면을 교체한다고 했는데 이때가 완료되는 시간인가?

그렇지 않다면 사용와 상호작용을 할 수 있을정도로 완전히 앱이 시작되어야 하나?

답은 전자이다. android vitals는 첫번째 프레임이 그려진 시점을 앱 시작이 완료되었다고 판단한다.

그리고 우리는 이렇게 첫번쨰 프레임이 그려진 시점까지 걸린 시간을 TTID라고 부른다.

### TTID(Time To Initial Display)

언급했다시피 TTID는 첫번쨰 프레임이 그려진 시점까지 걸린 시간을 의미한다.

TTID를 측정하는 방법은 아래와 같다.

### TTFD(Time To Full Display)

이와 비슷하게 TTFD라는 개념이 있다.

TTFD의 경우 앱이 완전히 실행되어 사용자와 상호작용할 수 있는 상태를 의미한다.

그런데 왜 android vitals는 TTFD가 아닌 TTID를 기준으로 완료 시점을 지정했을까?

개인적인 추측이긴 하지만 이는 TTFD가 가진 측정의 특성이 꽤나 수동적이기 때문이라고 생각한다.

일단 TTFD는 TTID와는 다르게 개발자가 직접 측정할 시점을 코드상에 지정해야한다.

위와같이 reportFullDrown()함수를 호출하게 된 시점에 로그캣에 완료시점이 출력된다.

다른말로 바꾸면 함수 호출 없이는 측정되지 않는 지표인 것이다.

또한 TTFD는 고려해야할 사항이 많다.

예를 들어 좋아하는 음악 리스트를 서버에서 받아오는 어플리케이션이 있다고 생각해보자.

이 경우 화면이 완전히 그려져 유저와 상호작용 하려면 네트워크 통신이 완료되는 시점을 고려해야한다.

### perfetto

perfetto를 사용하여 구체적인 앱 시작 과정 퍼포먼스를 확인할 수 있다고 한다.
이부분은 사실 나도 조만간 공부할 예정이라 여기에서는 구체적인 내용을 작성하지는 않을것같다.


## improve performance

그렇다면 만약 앱 시작 시간을 줄여야 할때 우리는 어떻게 성능을 향상시킬 수 있을까?

일단 문제가 되는 상황들을 알아보자

1. 과도한 앱 초기화
2. 과도한 액티비티 초기화
3. 커스텀 스플래시 화면